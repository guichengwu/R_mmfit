print(pmvnorm(upper=c(12.5, 16.5), mean=meanvec, sigma=covarmat))
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10)
k <- k - 10
p[i, k]  <- onesixth
}
}
p
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10)
k <- k - 10
p[i, k]  <- onesixth
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10)
k <- k-10
p[i, k]  <- onesixth
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10)
k <- k-10
p[i,k]  <- onesixth
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) {
k <- k-10
}
p[i,k]  <- onesixth
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) {
k <- k-10
}
p[i,k]  <- onesixth
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) {
k <- k-10
}
k
p[i,k]  <- onesixth
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) {
k <- k-10
}
p[i, k]<- onesixth
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) {
k <- k-10
}
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) {
k <- k-10
}
p[i,k] <- onesixth
}
}
p
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) k <- k-10
p[i,k] <- onesixth
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) k <- k-10
p[i,k] <- onesixth
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) k <- k-10
p[i,k] <- onesixth
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) k <- k-10
p[i,k] <- onesixth
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) k <- k-10
p[i,k] <- onesixth
}
}
p[i,k] <- onesixth
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k >= 10) k <- k-10
p[i,k] <- onesixth
}
}
p <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) k <- k-10
p[i,k] <- onesixth
}
}
qa <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) k <- k-10
pa[i,k] <- onesixth
}
}
qa <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) k <- k-10
qa[i,k] <- onesixth
}
}
qa <- maxtrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) k <- k-10
qa[i,k] <- onesixth
}
}
qa <- matrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) k <- k-10
qa[i,k] <- onesixth
}
}
qa
}
toss <- function() {
if (runif(1) < 0.5)
return('H')
else
return('T')
}
toss()
toss()
toss()
toss()
toss()
qa <- matrix(rep(0, 100), nrow=10)
onesixth <- 1/6
for (i in 1:10) {
for (j in 1:6) {
k <- i + j
if (k > 10) k <- k-10
qa[i,k] <- onesixth
}
}
findpi <- function(p) {
n <- nrow(p)
imp <- diag(n) - t(p)
imp[n, ] <- rep(1, n)
rhs <- c(rep(0, n-1), 1)
solve(imp, rhs)
}
altfindpi <- function(p, k) {
niters <- ceiling(log2(k))
prd <- p
for (i in 1:niters) {
prd <- prd %*% prd
}
colMeans(prd)
}
toss <- function() {
if (runif(1) < 0.5)
return('H')
else
return('T')
}
threeinrow <- function(ntimesteps) {
consec <- 0
nwins <- 0
wintimes <- 0
startplay <- 0
for (i in 1:ntimesteps) {
if (toss() == 'H') {
consec <- consec + 1
if (consec == 3) {
nwins <- nwins + 1
wintimes <- wintimes + i - startplay
consec <- 0
startplay <- i
}
} else {
consec <- 0
}
}
return(wintimes /nwins)
}
threeinrow(100)
z <- list()
z[[3]] <- 8
z
i  <- 6
z[[i]] <- 888
z
states <- rep(0, 10)
states
mcsim <- function(p, nsteps) {
z <- list()
stateNumbers <- nrow(p)
states <- rep(0, stateNumbers)
# initialize state begin from 1
currentState <- 1
for (i in 1:nsteps) {
#random number
r <- runif(1)
prob <- 0
for (j in 1:stateNumbers) {
prob <- prob + p[currentState, j]
if (prob >= u) {
currentState = j
break;
}
}
states[currentState] <- states[currentState] + 1
}
return(states/nsteps)
}
mcsim <- function(p, nsteps) {
z <- list()
stateNumbers <- nrow(p)
states <- rep(0, stateNumbers)
# initialize state begin from 1
currentState <- 1
for (i in 1:nsteps) {
#random number
r <- runif(1)
prob <- 0
for (j in 1:stateNumbers) {
prob <- prob + p[currentState, j]
if (prob >= u) {
currentState = j
break;
}
}
states[currentState] <- states[currentState] + 1
}
return(states/nsteps)
}
m <- matrix(rep(0, 9) , nrow=3)
m[1, 1] <- 0.5
m[1, 2] <- 0.5
m[2, 3] <- 0.5
m[2, 1] <- 0.5
m[3, 1] <- 1
mcsim(m, 1000)
mcsim <- function(p, nsteps) {
z <- list()
stateNumbers <- nrow(p)
states <- rep(0, stateNumbers)
# initialize state begin from 1
currentState <- 1
for (i in 1:nsteps) {
#random number
r <- runif(1)
prob <- 0
for (j in 1:stateNumbers) {
prob <- prob + p[currentState, j]
if (prob >= u) {
currentState = j
break;
}
}
states[currentState] <- states[currentState] + 1
}
return(states/nsteps)
}
m <- matrix(rep(0, 9) , nrow=3)
m[1, 1] <- 0.5
m[1, 2] <- 0.5
m[2, 3] <- 0.5
m[2, 1] <- 0.5
m[3, 1] <- 1
mcsim(m, 10000)
mcsim <- function(p, nsteps) {
z <- list()
stateNumbers <- nrow(p)
states <- rep(0, stateNumbers)
# initialize state
state <- ceiling(stateNumbers*runif(1))
for (i in 1:nsteps) {
#random number
r <- runif(1)
prob <- 0
newState <- state
for (j in 1:stateNumbers) {
prob <- prob + p[state, j]
if (prob >= u) {
newState = j
break;
}
}
state <- newState
states[state] <- states[state] + 1
}
return(states/nsteps)
}
m <- matrix(rep(0, 9) , nrow=3)
m[1, 1] <- 0.5
m[1, 2] <- 0.5
m[2, 3] <- 0.5
m[2, 1] <- 0.5
m[3, 1] <- 1
mcsim(m, 10000)
states[state] <- states[state] + 1
state
mcsim <- function(p, nsteps) {
z <- list()
stateNumbers <- nrow(p)
states <- rep(0, stateNumbers)
# initialize state
state <- ceiling(stateNumbers*runif(1))
for (i in 1:nsteps) {
#random number
r <- runif(1)
prob <- 0
newState <- state
for (j in 1:stateNumbers) {
prob <- prob + p[state, j]
if (prob >= u) {
newState = j
break;
}
}
state <- newState
states[state] <- states[state] + 1
}
return(states/nsteps)
}
m <- matrix(rep(0, 9) , nrow=3)
m[1, 1] <- 0.5
m[1, 2] <- 0.5
m[2, 3] <- 0.5
m[2, 1] <- 0.5
m[3, 1] <- 1
mcsim(m, 10000)
mcsim <- function(p, nsteps) {
z <- list()
stateNumbers <- nrow(p)
states <- rep(0, stateNumbers)
# initialize state
state <- ceiling(stateNumbers*runif(1))
for (i in 1:nsteps) {
#random number
r <- runif(1)
prob <- 0
newState <- state
for (j in 1:stateNumbers) {
prob <- prob + p[state, j]
if (prob >= r) {
newState = j
break;
}
}
state <- newState
states[state] <- states[state] + 1
}
return(states/nsteps)
}
m <- matrix(rep(0, 9) , nrow=3)
m[1, 1] <- 0.5
m[1, 2] <- 0.5
m[2, 3] <- 0.5
m[2, 1] <- 0.5
m[3, 1] <- 1
mcsim(m, 10000)
mcsim <- function(p, nsteps) {
z <- list()
stateNumbers <- nrow(p)
states <- rep(0, stateNumbers)
# initialize state
state <- ceiling(stateNumbers*runif(1))
for (i in 1:nsteps) {
#random number
r <- runif(1)
prob <- 0
newState <- state
for (j in 1:stateNumbers) {
prob <- prob + p[state, j]
if (prob >= r) {
newState = j
break;
}
}
state <- newState
states[state] <- states[state] + 1
}
return(states/nsteps)
}
m <- matrix(rep(0, 9) , nrow=3)
m[1, 1] <- 0.5
m[1, 2] <- 0.5
m[2, 3] <- 0.5
m[2, 1] <- 0.5
m[3, 1] <- 1
mcsim(m, 1000000)
mcsim <- function(p, nsteps) {
z <- list()
stateNumbers <- nrow(p)
states <- rep(0, stateNumbers)
# initialize state
state <- ceiling(stateNumbers*runif(1))
for (i in 1:nsteps) {
#random number
r <- runif(1)
prob <- 0
newState <- state
for (j in 1:stateNumbers) {
prob <- prob + p[state, j]
if (prob >= r) {
newState = j
break;
}
}
state <- newState
states[state] <- states[state] + 1
}
z <- states/nsteps
return(z)
}
# test case
m <- matrix(rep(0, 9) , nrow=3)
m[1, 1] <- 0.5
m[1, 2] <- 0.5
m[2, 3] <- 0.5
m[2, 1] <- 0.5
m[3, 1] <- 1
mcsim(m, 1000000)
